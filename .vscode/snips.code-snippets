{
  "use matrix": {
    "prefix": "use_matrix",
    "body": [
      "struct Matrix",
      "{",
      "    vector<vector<ll>> mat;",
      "    ll n, m;",
      "    Matrix(ll n, ll m)",
      "    {",
      "        this->n = n;",
      "        this->m = m;",
      "        mat.resize(n, vector<ll>(m, 0));",
      "    }",
      "    Matrix(vector<vector<ll>> mat)",
      "    {",
      "        this->mat = mat;",
      "        n = mat.size();",
      "        m = mat[0].size();",
      "    }",
      "    Matrix operator*(Matrix &other)",
      "    {",
      "        Matrix product(n, other.m);",
      "        for (ll i = 0; i < n; i++)",
      "        {",
      "            for (ll j = 0; j < other.m; j++)",
      "            {",
      "                for (ll k = 0; k < m; k++)",
      "                {",
      "                    product.mat[i][j] += mat[i][k] * other.mat[k][j];",
      "                    product.mat[i][j] %= MOD;",
      "                }",
      "            }",
      "        }",
      "        return product;",
      "    }",
      "    Matrix operator^(ll p)",
      "    {",
      "        Matrix res(n, m);",
      "        for (ll i = 0; i < n; i++)",
      "            res.mat[i][i] = 1;",
      "        Matrix a = *this;",
      "        while (p)",
      "        {",
      "            if (p & 1)",
      "                res = res * a;",
      "            a = a * a;",
      "            p >>= 1;",
      "        }",
      "        return res;",
      "    }",
      " ",
      "    void print()",
      "    {",
      "        for (ll i = 0; i < n; i++)",
      "        {",
      "            for (ll j = 0; j < m; j++)",
      "                cout << mat[i][j] << \" \";",
      "            cout << dl;",
      "        }",
      "    }",
      "};",
      " "
    ],
    "description": ""
  },
  "chorno clock": {
    "prefix": "use_clock",
    "body": [
      "#define use_chrono_clock(func)                                                \\",
      "    auto start = chrono::high_resolution_clock::now();                        \\",
      "    func();                                                                     \\",
      "    auto end = chrono::high_resolution_clock::now();                          \\",
      "    auto duration = chrono::duration_cast<chrono::microseconds>(end - start); \\",
      "    cout << \"Time: \" << duration.count() / 1000.00 << \" ms\" << endl;"
    ],
    "description": "chorno clock"
  },
  "pds": {
    "prefix": "pds",
    "body": [
      "",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "",
      "template <typename K, typename V, typename Comp = std::less<K>>",
      "using ordered_map = tree<K, V, Comp, rb_tree_tag, tree_order_statistics_node_update>;",
      "template <typename K, typename Comp = std::less<K>>",
      "using ordered_set = ordered_map<K, null_type, Comp>;",
      "template <typename K, typename V, typename Comp = std::less_equal<K>>",
      "using ordered_multimap = tree<K, V, Comp, rb_tree_tag, tree_order_statistics_node_update>;",
      "template <typename K, typename Comp = std::less_equal<K>>",
      "using ordered_multiset = ordered_multimap<K, null_type, Comp>;",
      ""
    ],
    "description": "pds"
  },

  "sieve": {
    "prefix": "sieve",
    "body": [
      "const ull N = 1e6 + 5;",
      "bool prime[N];",
      "void sieve()",
      "{",
      "    memset(prime, true, sizeof(prime));",
      "    prime[1] = false;",
      "    prime[0] = false;",
      "    for (int p = 2; p * p < N; p++)",
      "    {",
      "        if (prime[p] == true)",
      "        {",
      "",
      "            for (int i = p * p; i < N; i += p)",
      "                prime[i] = false;",
      "        }",
      "    }",
      "}"
    ],
    "description": "sieve"
  },
  "tprime": {
    "prefix": "tprime",
    "body": [
      "bool tprime(ll num)",
      "{",
      "    double y = sqrt(num);",
      "    ll x = sqrt(num);",
      "    return prime[x] && y == x;",
      "}",
      ""
    ],
    "description": "tprime"
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "ll gcd(ll a, ll b)",
      "{",
      "    if (a == 0)",
      "        return b;",
      "    return gcd(b % a, a);",
      "}",
      ""
    ],
    "description": "gcd"
  },
  "gcdAll": {
    "prefix": "gcdAll",
    "body": [
      "ll gcdAll(vector<ll> &nums, int from = 0)",
      "{",
      "    ll n = sz(nums);",
      "    ll cur = nums[from];",
      "    for (ll i = from + 1; i < n; i++)",
      "    {",
      "        cur = gcd(cur, nums[i]);",
      "    }",
      "    return cur;",
      "}"
    ],
    "description": "gcdAll"
  },
  "all Equal": {
    "prefix": "all_equal",
    "body": [
      "bool all_equal(vector<ll> &nums, int from = 0)",
      "{",
      "    int n = sz(nums);",
      "    ll cur = nums[from];",
      "    for (ll i = from + 1; i < n; i++)",
      "    {",
      "        if (cur != nums[i])",
      "            return false;",
      "    }",
      "    return true;",
      "}"
    ],
    "description": "all Equal"
  },
  "sigma": {
    "prefix": "sigma",
    "body": ["ull sigma(ull x)", "{", "    return x * (x + 1) / 2;", "}"],
    "description": "sigma"
  },
  "sum_num": {
    "prefix": "sum_num",
    "body": [
      "ll sum_num(ll n)",
      "{",
      "    ll sum = 0;",
      "    while (n > 0)",
      "    {",
      "        sum += (n % 10);",
      "        n /= 10;",
      "    }",
      "    return sum;",
      "}"
    ],
    "description": "sum_num"
  },
  "custom_pow": {
    "prefix": "custom_pow",
    "body": [
      "ull custom_pow(ull a, ull b)",
      "{",
      "    ull res = 1;",
      "    while (b--)",
      "        res *= a;",
      "",
      "    return res;",
      "}"
    ],
    "description": "custom_pow"
  },
  "custom_log": {
    "prefix": "custom_log",
    "body": [
      "ll custom_log(ll a, ll b)",
      "{",
      "    return log2(a) / log2(b);",
      "}"
    ],
    "description": "custom_log"
  },

  "primeFactors": {
    "prefix": "primeFactors",
    "body": [
      "vec primeFactors(ll n)",
      "{",
      "    vec factors;",
      "    while (n % 2 == 0)",
      "    {",
      "        factors.push_back(2);",
      "        n = n / 2;",
      "    }",
      "",
      "    for (ll i = 3; i*i <= n; i = i + 2)",
      "    {",
      "        while (n % i == 0)",
      "        {",
      "            factors.push_back(i);",
      "            n = n / i;",
      "        }",
      "    }",
      "",
      "    if (n > 2)",
      "        factors.push_back(n);",
      "",
      "    return factors;",
      "}",
      ""
    ],
    "description": "primeFactors"
  },

  "sigmaSquared": {
    "prefix": "sigmaSquared",
    "body": [
      "ull sigmaSquared(ull x)",
      "{",
      "    return (((x * ((x + 1))) * (((x * 2) + 1)))) / 6;",
      "}"
    ],
    "description": "sigmaSquared"
  },
  "gen_palands": {
    "prefix": "gen_palands",
    "body": [
      "int createPalindrome(int input, int b, bool isOdd)",
      "{",
      "    int n = input;",
      "    int palin = input;",
      "",
      "    if (isOdd)",
      "        n /= b;",
      "",
      "    while (n > 0)",
      "    {",
      "        palin = palin * b + (n % b);",
      "        n /= b;",
      "    }",
      "    return palin;",
      "}",
      "vec palands;",
      "void generatePalindromes(int n)",
      "{",
      "    int number;",
      "",
      "    for (int j = 0; j < 2; j++)",
      "    {",
      "        int i = 1;",
      "        while ((number = createPalindrome(i, 10, j % 2)) < n)",
      "        {",
      "            palands.push_back(number);",
      "            i++;",
      "        }",
      "    }",
      "}"
    ],
    "description": "gen_palands"
  },
  "get_freq": {
    "prefix": "get_freq",
    "body": [
      "void get_freq(vec &arr, str s)",
      "{",
      "    for (const char ch of s)",
      "        arr[ch - 'a']++;",
      "}"
    ],
    "description": "get_freq"
  },
  "bs_sqrt": {
    "prefix": "bs_sqrt",
    "body": [
      "ll bs_sqrt(ll x)",
      "{",
      "    ll left = 0, right = 2000000123;",
      "    while (right > left)",
      "    {",
      "        ll mid = (left + right) / 2;",
      "",
      "        if (mid * mid > x)",
      "            right = mid;",
      "        else",
      "            left = mid + 1;",
      "    }",
      "    return left - 1;",
      "}",
      ""
    ],
    "description": "bs_sqrt"
  },
  "isprime": {
    "prefix": "isprime",
    "body": [
      "ll mpow(ll n, ll p, ll m)",
      "{",
      "    if (!p)",
      "        return 1;",
      "    else if (p & 1)",
      "        return (n * mpow(n, p - 1, m)) % m;",
      "    else",
      "    {",
      "        ll v = mpow(n, p / 2, m);",
      "        return (v * v) % m;",
      "    }",
      "}",
      "bool isprime(ll n)",
      "{",
      "    if (n < 2)",
      "        return false;",
      "    for (ll i = 2; i * i * i <= n; ++i)",
      "        if (n % i == 0)",
      "            return false;",
      "    for (int it = 0; it < 1e5; ++it)",
      "    {",
      "        ll i = rand() % (n - 1) + 1;",
      "        if (__gcd(i, n) != 1)",
      "            return false;",
      "        if (mpow(i, n - 1, n) != 1)",
      "            return false;",
      "    }",
      "    return true;",
      "}"
    ],
    "description": "isprime"
  },
  "is_prime": {
    "prefix": "is_prime",
    "body": [
      "bool is_prime(ull n)",
      "{",
      "    // Check if a number is prime",
      "    if (n <= 1)",
      "        return false;",
      "    for (ull i = 2; i * i <= n; i++)",
      "        if (n % i == 0)",
      "            return false;",
      "    return true;",
      "}"
    ],
    "description": "is_prime"
  },

  "Deci to Base K": {
    "prefix": "to_base_k",
    "body": [
      "char reVal(int num)",
      "{",
      "    if (num >= 0 && num <= 9)",
      "        return (char)(num + '0');",
      "    else",
      "        return (char)(num - 10 + 'A');",
      "}",
      "",
      "void strev(char *str)",
      "{",
      "    int len = strlen(str);",
      "    int i;",
      "    for (i = 0; i < len / 2; i++)",
      "    {",
      "        char temp = str[i];",
      "        str[i] = str[len - i - 1];",
      "        str[len - i - 1] = temp;",
      "    }",
      "}",
      "",
      "char *fromDeci(char res[100], ll base, ll inputNum)",
      "{",
      "    int index = 0;",
      "",
      "    while (inputNum > 0)",
      "    {",
      "        res[index++] = reVal(inputNum % base);",
      "        inputNum /= base;",
      "    }",
      "    res[index] = '\\0';",
      "",
      "    strev(res);",
      "",
      "    return res;",
      "}",
      ""
    ],
    "description": "Deci to Base K"
  },
  "Segment Tree": {
    "prefix": "sgt",
    "body": [
      "",
      "struct Node",
      "{",
      "    long long val;",
      "    Node() { val = 0; }",
      "    Node(long long val) : val(val) {}",
      "};",
      "struct Operation",
      "{",
      "    virtual Node work(Node, Node) { return Node(); }",
      "};",
      "struct SegmentTree",
      "{",
      "    int size;",
      "    Node DEFAULT;",
      "    vector<Node> data;",
      "    Operation *operation;",
      "    void init(int n, Node DEFAULT, Operation *operation)",
      "    {",
      "        size = 1;",
      "        this->operation = operation;",
      "        this->DEFAULT = DEFAULT;",
      "        while (size < n)",
      "            size *= 2;",
      "        data.assign(2 * size, Node()); // asigin it to the cloeset poewr of two",
      "    }",
      "    void set(int i, Node value, int node, int beginSeg, int endSeg)",
      "    {",
      "        if (beginSeg == endSeg)",
      "        {",
      "            data[node] = value;",
      "            return;",
      "        }",
      "",
      "        int mid = (beginSeg + endSeg) / 2;",
      "        if (i <= mid)",
      "            set(i, value, 2 * node, beginSeg, mid);",
      "        else",
      "            set(i, value, 2 * node + 1, mid + 1, endSeg);",
      "",
      "        data[node] = operation->work(data[2 * node], data[2 * node + 1]);",
      "    }",
      "",
      "    Node query(int left, int right, int node, int beginSeg, int endSeg)",
      "    {",
      "        if (beginSeg > right || left > endSeg)",
      "            return DEFAULT;",
      "",
      "        if (beginSeg >= left && endSeg <= right)",
      "            return data[node];",
      "",
      "        int mid = (beginSeg + endSeg) / 2;",
      "        Node a = this->query(left, right, 2 * node, beginSeg, mid);",
      "        Node b = this->query(left, right, 2 * node + 1, mid + 1, endSeg);",
      "",
      "        return operation->work(a, b);",
      "    }",
      "    Node query(int left, int right)",
      "    {",
      "",
      "        return query(left, right, 1, 1, size);",
      "    }",
      "    void set(int i, Node value)",
      "    {",
      "        set(i, value, 1, 1, size);",
      "    }",
      "};",
      ""
    ],
    "description": "Segment Tree"
  },
  "deq1": {
    "prefix": "deq_out",
    "body": [
      "template <typename T>",
      "ostream &operator<<(ostream &out, deque<T> &outto)",
      "{",
      "    for (ll i = 0; i < size(outto); i++)",
      "        out << outto[i] << \" \";",
      "    return out;",
      "}"
    ],
    "description": ""
  },
  "deq2": {
    "prefix": "deq_in",
    "body": [
      "template <typename T>",
      "istream &operator>>(istream &in, deque<T> &into)",
      "{",
      "    for (ll i = 0; i < size(into); i++)",
      "        in >> into[i];",
      "",
      "    return in;",
      "}"
    ],
    "description": ""
  },
  "LazyPropagationSegmentTree": {
    "prefix": "sgtlazy",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "struct LazyPropagationSegmentTree",
      "{",
      "    int size;",
      "    long long DEFAULT;",
      "    vector<long long> data, lazy;",
      "    void init(int n, long long DEFAULT)",
      "    {",
      "        size = 1;",
      "        this->DEFAULT = DEFAULT;",
      "        while (size < n)",
      "            size *= 2;",
      "        data.assign(2 * size, DEFAULT);",
      "        lazy.assign(2 * size, DEFAULT);",
      "    }",
      "    void workLazy(int &node, int &beginSeg, int &endSeg)",
      "    {",
      "        if (lazy[node] != DEFAULT)",
      "        {",
      "            long long dx = lazy[node];",
      "            lazy[node] = DEFAULT;",
      "            data[node] += dx * (endSeg - beginSeg + 1);",
      "            if (beginSeg != endSeg)",
      "            {",
      "                lazy[2 * node] += dx;",
      "                lazy[2 * node + 1] += dx;",
      "            }",
      "        }",
      "    }",
      "    void set(int left, int right, int node, int beginSeg, int endSeg, ll value)",
      "    {",
      "        workLazy(node, beginSeg, endSeg);",
      "",
      "        if (beginSeg > right || left > endSeg)",
      "            return;",
      "",
      "        if (beginSeg >= left && endSeg <= right)",
      "        {",
      "            long long dx = value * (endSeg - beginSeg + 1);",
      "            data[node] += dx;",
      "",
      "            if (beginSeg != endSeg)",
      "            {",
      "                lazy[2 * node] += value;",
      "                lazy[2 * node + 1] += value;",
      "            }",
      "            return;",
      "        }",
      "",
      "        int mid = (beginSeg + endSeg) / 2;",
      "        this->set(left, right, 2 * node, beginSeg, mid, value);",
      "        this->set(left, right, 2 * node + 1, mid + 1, endSeg, value);",
      "",
      "        data[node] = data[2 * node] + data[2 * node + 1];",
      "    }",
      "",
      "    long long query(int left, int right, int node, int beginSeg, int endSeg)",
      "    {",
      "        workLazy(node, beginSeg, endSeg);",
      "",
      "        if (beginSeg > right || left > endSeg)",
      "            return DEFAULT;",
      "",
      "        if (beginSeg >= left && endSeg <= right)",
      "            return data[node];",
      "",
      "        int mid = (beginSeg + endSeg) / 2;",
      "        long long a = this->query(left, right, 2 * node, beginSeg, mid);",
      "        long long b = this->query(left, right, 2 * node + 1, mid + 1, endSeg);",
      "",
      "        return a + b;",
      "    }",
      "    long long query(int left, int right)",
      "    {",
      "",
      "        return query(left, right, 1, 1, size);",
      "    }",
      "    void set(int left, int right, long long value)",
      "    {",
      "        set(left, right, 1, 1, size, value);",
      "    }",
      "};"
    ],
    "description": "LazyPropagationSegmentTree"
  },
  "pairs_in": {
    "prefix": "pairs_in",
    "body": [
      "template <typename T, typename S>",
      "istream &operator>>(istream &in, vector<pair<T, S>> &into)",
      "{",
      "    for (ll i = 0; i < size(into); i++)",
      "        in >> into[i].first >> into[i].second;",
      "",
      "    return in;",
      "}"
    ],
    "description": "pairs_in"
  },
  "pairs_out": {
    "prefix": "pairs_out",
    "body": [
      "",
      "template <typename T, typename S>",
      "ostream &operator<<(ostream &out, vector<pair<T, S>> &outto)",
      "{",
      "    for (ll i = 0; i < size(outto); i++)",
      "        out << outto[i].first << \"->\" << outto[i].second << ' ';",
      "    return out;",
      "}"
    ],
    "description": "pairs_out"
  },
  "de": {
    "prefix": "debug",
    "body": ["debug {", "  $1", "}"]
  },
  "use_2d": {
    "prefix": "use_2d",
    "body": [
      "template <typename T>",
      "istream &operator>>(istream &in, vector<vector<T>> &into)",
      "{",
      "    for (ll i = 0; i < size(into); i++)",
      "        for (ll j = 0; j < size(into[i]); j++)",
      "            in >> into[i][j];",
      "",
      "    return in;",
      "}",
      "template <typename T>",
      "ostream &operator<<(ostream &out, vector<vector<T>> &outto)",
      "{",
      "    for (ll i = 0; i < size(outto); i++)",
      "    {",
      "        for (int j = 0; j < outto[i].size(); j++)",
      "        {",
      "            out << outto[i][j] << \" \";",
      "        }",
      "        cout << endl;",
      "    }",
      "    return out;",
      "}"
    ],
    "description": "use_2d"
  },
  "DSU": {
    "prefix": "dsu",
    "body": [
      "template <typename T = int, int Base = 1>",
      "struct DSU",
      "{",
      "",
      "    vector<T> parent, Gsize;",
      "",
      "    DSU(int MaxNodes)",
      "    {",
      "        parent = Gsize = vector<T>(MaxNodes + 5);",
      "        for (int i = Base; i <= MaxNodes; i++)",
      "            parent[i] = i, Gsize[i] = 1;",
      "    }",
      "",
      "    T find_leader(int node)",
      "    {",
      "        return parent[node] = (parent[node] == node ? node : find_leader(parent[node]));",
      "    }",
      "",
      "    bool is_same_sets(int u, int v)",
      "    {",
      "        return find_leader(u) == find_leader(v);",
      "    }",
      "",
      "    void union_sets(int u, int v)",
      "    {",
      "        int leader_u = find_leader(u), leader_v = find_leader(v);",
      "        if (leader_u == leader_v)",
      "            return;",
      "        if (Gsize[leader_u] < Gsize[leader_v])",
      "            swap(leader_u, leader_v);",
      "        Gsize[leader_u] += Gsize[leader_v], parent[leader_v] = leader_u;",
      "    }",
      "",
      "    int get_size(int u)",
      "    {",
      "        return Gsize[find_leader(u)];",
      "    }",
      "};"
    ],
    "description": "DSU"
  },
  "str_sub": {
    "prefix": "str_sub",
    "body": [
      "struct Str_Sub_Digit_Res",
      "{",
      "    int r;",
      "    int b;",
      "};",
      "struct Str_Sub_Digit_Res subDigits(char c1, char c2, int b)",
      "{",
      "    Str_Sub_Digit_Res res;",
      "    int d1 = c1 - '0';",
      "    int d2 = c2 - '0';",
      "    int n = d1 - d2 - b;",
      "    if (n >= 0)",
      "    {",
      "        res.r = n;",
      "        res.b = 0;",
      "    }",
      "    else",
      "    {",
      "        res.r = n + 10;",
      "        res.b = 1;",
      "    }",
      "    return res;",
      "}",
      "string stripLeadingZero(string s)",
      "{",
      "    string new_s = s;",
      "    int i = 0;",
      "    while (i < s.size() && s[i] == '0')",
      "        i++;",
      "    if (i == s.size())",
      "        return \"0\";",
      "    return s.substr(i);",
      "}",
      "string str_sub(string a, string b)",
      "{",
      "    int borrow = 0;",
      "    string res;",
      "    for (int i = a.size() - 1; i >= 0; i--)",
      "    {",
      "        struct Str_Sub_Digit_Res t = subDigits(a[i], b[i], borrow);",
      "        borrow = t.b;   ",
      "        res = char('0' + t.r) + res;",
      "    }",
      "",
      "    return stripLeadingZero(res);",
      "}"
    ],
    "description": "str_sub"
  },
  "snoob": {
    "prefix": "snoob",
    "body": [
      "uint64_t snoob(uint64_t x)",
      "{",
      "    uint64_t smallest, ripple, ones;",
      "    smallest = x & -x;",
      "    ripple = x + smallest;",
      "    ones = x ^ ripple;",
      "    ones = (ones >> 2) / smallest;",
      "",
      "    rt(ripple | ones);",
      "}"
    ],
    "description": ""
  },
  "extended_ecluid": {
    "prefix": "extended_ecluid",
    "body": [
      "long long extended_ecluid(long long a, long long b, long long &x, long long &y)",
      "{",
      "    if (b == 0)",
      "    {",
      "        x = 1;",
      "        y = 0;",
      "        return a;",
      "    }",
      "    long long x1, y1;",
      "    long long d = extended_ecluid(b, a % b, x1, y1);",
      "    x = y1;",
      "    y = x1 - y1 * (a / b);",
      "    return d;",
      "}"
    ],
    "description": "extended_ecluid"
  },
  "mx_subseq_sum": {
    "prefix": "mx_subseq_sum",
    "body": [
      "ll mx_subseq_sum(vec &nums)",
      "{",
      "    ll cur = 0;",
      "    ll mx = -OOO;",
      "",
      "    for (int i = 0; i < nums.size(); i++)",
      "    {",
      "        cur += nums[i];",
      "        if (cur <= 0)",
      "            cur = 0;",
      "        mx = max(cur, mx);",
      "    }",
      "",
      "    rt mx;",
      "}"
    ],
    "description": "mx_subseq_sum"
  },
  "nCr": {
    "prefix": "nCk",
    "body": [
      "unsigned long long nCk(unsigned long long n,long long  unsigned k )",
      "{",
      "    if (k > n) return 0;",
      "    if (k * 2 > n) k = n-k;",
      "    if (k == 0) return 1;",
      "",
      "    unsigned long long result = n;",
      "    for( long long i = 2; i <= k; ++i ) {",
      "        result *= (n-i+1);",
      "        result /= i;",
      "    }",
      "    return result;",
      "}"
    ],
    "description": "nCr"
  },

  "factors": {
    "prefix": "factors",
    "body": [
      "",
      "vec factors(ll n)",
      "{",
      "    vec res;",
      "    for (ll x = 1; x * x <= n; x++)",
      "    {",
      "        if (n % x == 0)",
      "        {",
      "            if (n / x != x)",
      "                res.push_back(n / x);",
      "            res.push_back(x);",
      "        }",
      "    }",
      "",
      "    return res;",
      "}"
    ],
    "description": "factors"
  },
  "2d_sliding_window": {
    "prefix": "2d_sliding_window",
    "body": [
      "class MinQ",
      "{",
      "public:",
      "    queue<int> q;",
      "    deque<int> dq;",
      "    void push(int x)",
      "    {",
      "        q.push(x);",
      "        while (!dq.empty() && x < dq.back())",
      "        {",
      "            dq.pop_back();",
      "        }",
      "        dq.push_back(x);",
      "    }",
      "    void pop()",
      "    {",
      "        if (q.front() == dq.front())",
      "        {",
      "            q.pop();",
      "            dq.pop_front();",
      "        }",
      "        else",
      "            q.pop();",
      "    }",
      "    int min()",
      "    {",
      "        return dq.front();",
      "    }",
      "};",
      "",
      "vector<int> minSliding_1d_Window(vector<int> &v, int k)",
      "{",
      "    MinQ q;",
      "    int n = v.size();",
      "    vector<int> ans;",
      "    for (int i = 0; i < k; i++)",
      "    {",
      "        q.push(v[i]);",
      "    }",
      "    for (int i = k; i < n; i++)",
      "    {",
      "        ans.push_back(q.min());",
      "        q.pop();",
      "        q.push(v[i]);",
      "    }",
      "    ans.push_back(q.min());",
      "    return ans;",
      "}",
      "vector<vector<int>> minSliding_2d_Window(vector<vector<int>> v, int k)",
      "{",
      "",
      "    int n = v.size();",
      "    int m = v[0].size();",
      "",
      "    // caclulting sliding window horizontally",
      "    vector<vector<int>> horizontal;",
      "    for (int i = 0; i < v.size(); i++)",
      "    {",
      "        vector<int> part = minSliding_1d_Window(v[i], k);",
      "        horizontal.push_back(part);",
      "    }",
      "",
      "    vector<vector<int>> final(n - k + 1, vector<int>(m - k + 1, -3));",
      "    int c = 0;",
      "",
      "    // calculationg sliding window vertically",
      "    for (int j = 0; j < horizontal[0].size(); j++)",
      "    {",
      "        vector<int> v;",
      "        for (int i = 0; i < horizontal.size(); i++)",
      "        {",
      "            v.push_back(horizontal[i][j]);",
      "        }",
      "        vector<int> tmp = minSliding_1d_Window(v, k);",
      "",
      "        // pushing the result in our resultant matrix",
      "        for (int index = 0; index < n - k + 1; index++)",
      "        {",
      "            final[index][c] = tmp[index];",
      "        }",
      "        c++;",
      "    }",
      "",
      "    // return final matrix",
      "    return final;",
      "}"
    ],
    "description": "2d_sliding_window"
  },

  "compress": {
    "prefix": "compress",
    "body": [
      "pair<vector<int>, vector<int>> compress(vector<int> a)",
      "{",
      "    sort(all(a));",
      "    a.erase(unique(all(a)), a.end());",
      "    vector<int> b = a;",
      "",
      "    for (int &i : a)",
      "        i = lower_bound(all(b), i) - b.begin();",
      "    return {b, a};",
      "}"
    ],
    "description": "compress"
  },
  "weight dsu": {
    "prefix": "wdsu",
    "body": [
      "#define int long long",
      "template <typename T = int, int Base = 1>",
      "struct DSU",
      "{",
      "",
      "    vector<T> parent;",
      "    vector<ll> weight;",
      "",
      "    DSU(int MaxNodes)",
      "    {",
      "        parent = vector<T>(MaxNodes + 5);",
      "        weight = vector<ll>(MaxNodes + 5);",
      "        for (int i = Base; i <= MaxNodes; i++)",
      "            parent[i] = i, weight[i] = 0;",
      "    }",
      "",
      "    T find_leader(int node)",
      "    {",
      "        if (parent[node] == node)",
      "            return node;",
      "        ll par = find_leader(parent[node]);",
      "        weight[node] += weight[parent[node]];",
      "        return parent[node] = par;",
      "    }",
      "",
      "    bool is_same_sets(int u, int v)",
      "    {",
      "        return find_leader(u) == find_leader(v);",
      "    }",
      "",
      "    bool union_sets(int u, int v, ll w)",
      "    {",
      "        ll par_u = find_leader(u);",
      "        ll par_v = find_leader(v);",
      "        if (par_u == par_v)",
      "            return weight[v] - weight[u] == w;",
      "",
      "        parent[par_u] = par_v;",
      "        weight[par_u] = weight[v] - weight[u] - w;",
      "",
      "        return true;",
      "    }",
      "};",
      ""
    ],
    "description": "weight dsu"
  },
  "get a sing of any tirnagle ": {
    "prefix": "sin",
    "body": [
      "sin(acos(-1) / 2 - acos((a * a + b * b - c * c) / (2.0 * a * b)))",
      ""
    ],
    "description": "get a sing of any tirnagle "
  },
  "": {
    "prefix": "use_points",
    "body": [
      "#include <complex>",
      "",
      "#define PI acos(-1)",
      "#define EPS 1e-9",
      "",
      "#define point complex<double>",
      "#define x real()",
      "#define y imag()",
      "",
      "#define polar(r, theta) (r) * exp(point(0, (theta)))",
      "",
      "#define angle(v) (atan2((v).y, (v).x))",
      "#define angleToVector(t) (polar(1, t))",
      "#define vec(a, b) ((b) - (a))",
      "#define length(v) ((double)hypot((v).y, (v).x))",
      "#define dot(a, b) ((conj(a) * (b)).x)   // a*b*cos(theta)",
      "#define cross(a, b) ((conj(a) * (b)).y) // a*b*sin(theta)",
      "#define lengthSqr(v) (dot(v, v))",
      "#define same(a, b) (dot(vec(a, b), vec(a, b)) < EPS)",
      "#define normalize(v) ((v) / length(v))",
      "#define norm(a) (conj(a) * (a)).x",
      "",
      "#define rotate0(v, t) ((v) * exp(point(0, t)))",
      "#define rotateA(p, a, t) (rotate0(vec(a, p), t) + a)",
      "#define reflect0(v, m) (conj((v) / (m)) * (m))",
      "",
      "int double_compare(double a, double b)",
      "{",
      "    return fabs(a - b) <= EPS ? 0 : a < b ? -1",
      "                                          : 1;",
      "}",
      "",
      "point reflect(point p, point p0, point p1)",
      "{",
      "    point z = p - p0, w = p1 - p0;",
      "    return conj(z / w) * w + p0;",
      "}",
      "",
      "bool is_collinear(point a, point b, point c)",
      "{",
      "    return fabs(cross(b - a, c - a)) < EPS;",
      "}",
      "",
      "bool is_point_on_ray(point p0, point p1, point p2)",
      "{",
      "    if (not is_collinear(p0, p1, p2))",
      "        return false;",
      "    return double_compare(dot(p1 - p0, p2 - p0), 0) == 1;",
      "}",
      "bool is_point_on_ray2(point p0, point p1, point p2)",
      "{",
      "    if (length(p2 - p0) < EPS)",
      "        return true;",
      "",
      "    return same(normalize(p1 - p0), normalize(p2 - p0));",
      "}",
      "",
      "bool is_point_on_segment(point a, point b, point c)",
      "{",
      "    return is_point_on_ray(a, b, c) and is_point_on_ray(b, a, c);",
      "}",
      "",
      "double dist_to_line(point p0, point p1, point p2)",
      "{",
      "    return fabs(cross(p1 - p0, p2 - p0) / length(p0 - p1));",
      "}",
      "double dist_to_segment(point p0, point p1, point p2)",
      "{",
      "    double d1, d2;",
      "    point v1 = p1 - p0, v2 = p2 - p0;",
      "    if ((d1 = dot(v1, v2)) <= 0)",
      "        return length(p2 - p0);",
      "    if ((d2 = dot(v1, v1)) <= d1)",
      "        return length(p2 - p1);",
      "",
      "    double d = d1 / d2;",
      "    return length(p2 - (p0 + v1 * d));",
      "}",
      "",
      "bool intersect_segments(point a, point b, point c, point d, point &intersect)",
      "{",
      "    double d1 = cross(a - b, d - c), d2 = cross(a - c, d - c), d3 = cross(a - b, a - c);",
      "",
      "    if (fabs(d1) < EPS)",
      "        return false;",
      "",
      "    double t1 = d2 / d1, t2 = d3 / d1;",
      "",
      "    intersect = a + (b - a) * t1;",
      "",
      "    if (t1 < -EPS or t2 < -EPS or t2 > 1 + EPS)",
      "        return false;",
      "",
      "    return true;",
      "}",
      "int counterClockWise(point p0, point p1, point p2)",
      "{",
      "    point v1(p1 - p0), v2(p2 - p0);",
      "    if (cross(v1, v2) > EPS)",
      "        return 1;",
      "    if (cross(v1, v2) < -EPS)",
      "        return -1;",
      "    if (v1.x * v2.x < 0 or v1.y * v2.y < 0)",
      "        return -1;",
      "",
      "    if (norm(v1) < norm(v2) - EPS)",
      "        return 1;",
      "",
      "    return 0;",
      "}",
      "int clockWise(point p0, point p1, point p2)",
      "{",
      "    return -counterClockWise(p0, p1, p2);",
      "}",
      "bool intersect_segments_handle_point(point p1, point p2, point p3, point p4)",
      "{",
      "",
      "    bool X = (p1 == p2), Y = (p3 == p4);",
      "",
      "    if (X and Y)",
      "        return p1 == p3;",
      "    if (X)",
      "        return counterClockWise(p3, p4, p1) == 0;",
      "    if (Y)",
      "        return counterClockWise(p1, p2, p3) == 0;",
      "",
      "    return (counterClockWise(p1, p2, p3) * counterClockWise(p1, p2, p4) <= 0) and (counterClockWise(p3, p4, p1) * counterClockWise(p3, p4, p2) <= 0);",
      "}",
      ""
    ],
    "description": ""
  },
  "cp": {
    "prefix": "cp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "const string dl = \"\\n\";",
      "typedef long long ll;",
      "#define all(v) v.begin(), v.end()",
      "#define rall(v) v.rbegin(), v.rend()",
      "",
      "",
      "",
      "void solve()",
      "{",
      "    $1",
      "}",
      "",
      "int main()",
      "{",
      "",
      "#ifndef ONLINE_JUDGE",
      "    freopen(\"input.txt\", \"r\", stdin);",
      "    freopen(\"output.txt\", \"w\", stdout);",
      "#endif",
      "    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
      "",
      "    int tc = 1;",
      "",
      "    cin >> tc;",
      "",
      "    for (int t = 1; t <= tc; t++)",
      "    {",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "cp"
  },
  "mod shit": {
    "prefix": "mod",
    "body": [
      "const ll MOD = 998244353;",
      "",
      "ll add_mod(ll a, ll b)",
      "{",
      "    return (a + b) % MOD;",
      "}",
      "ll mul_mod(ll a, ll b)",
      "{",
      "    return (a * b) % MOD;",
      "}",
      "ll sub_mod(ll a, ll b)",
      "{",
      "    return (a - b + MOD) % MOD;",
      "}",
      "ll pow_mod(ll a, ll b)",
      "{",
      "    ll res = 1;",
      "    while (b)",
      "    {",
      "        if (b & 1)",
      "        {",
      "            res = mul_mod(res, a);",
      "        }",
      "        a = mul_mod(a, a);",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}",
      "",
      "ll inv_mod(ll a)",
      "{",
      "    return pow_mod(a, MOD - 2);",
      "}",
      "ll div_mod(ll a, ll b)",
      "{",
      "    return mul_mod(a, inv_mod(b));",
      "}",
      ""
    ],
    "description": "mod shit"
  },
  "log mod": {
    "prefix": "log_mod",
    "body": [
      "ll log_mod(ll a, ll b)",
      "{",
      "    // a^n = b mod p",
      "    ll n = sqrt(MOD) + 1;",
      "    map<ll, ll> mp;",
      "    ll an = 1;",
      "    for (ll i = 0; i < n; i++)",
      "    {",
      "        if (mp.find(an) == mp.end())",
      "            mp[an] = i;",
      "        an = (an * a) % MOD;",
      "    }",
      "    ll inva = inv(power(a, n));",
      "    ll cur = b;",
      "    for (ll i = 0; i < n; i++)",
      "    {",
      "        if (mp.find(cur) != mp.end())",
      "            return i * n + mp[cur];",
      "        cur = (cur * inva) % MOD;",
      "    }",
      "    return -1;",
      "}"
    ],
    "description": ""
  }
}
